## 延迟任务的实现总结
### 延迟任务描述
延迟任务有别于定式任务，定式任务往往是固定周期的，有明确的触发时间。而延迟任务一般没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件。延迟任务相关的业务场景如下：
* 12306车票下单后，如果一个小时之后未付款，订单会取消
* 某个操作之后需要在30分钟之后，发送一条消息给用户
* 物联网系统经常会遇到向终端下发命令，如果命令一段时间没有应答，就需要设置成超时。
上面的问题其实就是平时常见的延迟任务问题了。

下面我们来探讨一些方案，其实这些方案没有好坏之分，和系统架构一样，只有最适合。对于数据量较小的情况下，任意一种方案都可行，考虑的是简单明了和开发速度，尽量避免把系统搞复杂了。而对于数据量较大的情况下，就需要有一些选择，并不是所有的方案都适合了。
#### 01: 数据库轮询
这是比较常见的一种方式，所有的订单或者所有的命令一般都会存储在数据库中。我们会起一个线程去扫数据库或者一个数据库定时Job，找到那些超时的数据，直接更新状态，或者拿出来执行一些操作。这种方式很简单，不会引入其他的技术，开发周期短。

如果数据量比较大，千万级甚至更多，插入频率很高的话，上面的方式在性能上会出现一些问题，查找和更新对会占用很多时间，轮询频率高的话甚至会影响数据入库。一种可以尝试的方式就是使用类似TBSchedule或Elastic-Job这样的分布式的任务调度加上数据分片功能，把需要判断的数据分到不同的机器上执行。

如果数据量进一步增大，那扫数据库肯定就不行了。另一方面，对于订单这类数据，我们也许会遇到分库分表，那上述方案就会变得过于复杂，得不偿失。
#### 02: 语言本身提供的延迟队列包
比如Java中提供了一个DelayQueue包用来处理延迟队列。这种方式的任务都存储在内存中，程序重启，将导致任务丢失。
#### 03: 环形队列（时间轮）
时间轮是一种非常惊艳的数据结构。其在Linux内核中使用广泛，是Linux内核定时器的实现方法和基础之一。按使用场景，大致可以分为两种时间轮：原始时间轮和分层时间轮。分层时间轮是原始时间轮的升级版本，来应对时间“槽”数量比较大的情况，对内存和精度都有很高要求的情况。我们延迟任务的场景一般只需要用到原始时间轮就可以了。

原始时间轮：如下图一个轮子，有8个“槽”，可以代表未来的一个时间。如果以秒为单位，中间的指针每隔一秒钟转动到新的“槽”上面，就好像手表一样。如果当前指针指在1上面，我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。那如果需要在20秒之后执行怎么办，由于这个环形结构槽数只到8，如果要20秒，指针需要多转2圈。位置是在2圈之后的5上面（20 % 8 + 1）。这个圈数需要记录在槽中的数据结构里面。这个数据结构最重要的是两个指针，一个是触发任务的函数指针，另外一个是触发的总第几圈数。时间轮可以用简单的数组或者是环形链表来实现。

和上面的方式一样，任务都存储在内存中，程序重启，将导致任务丢失。此时在任务开始的时候先固化，然后在处理，处理完之后再删除固化数据。如果服务重启要重新启动所有根据固化的数据重新构建任务。
#### 04: Redis ZSet

#### 05: 成熟的消息队列提供延迟队列功能
例如：RabbitMQ的TTL和DXL就能实现延迟队列。

### 延时队列
https://liuzhengyang.github.io/2017/01/03/delay-queue/

https://www.cnblogs.com/hzmark/p/mq-delay-msg.html

https://www.jianshu.com/p/7beebbc61229

https://tech.youzan.com/queuing_delay/

http://www.rowkey.me/blog/2017/12/28/delay-trigger/

http://www.cnblogs.com/haoxinyue/p/6663720.html

